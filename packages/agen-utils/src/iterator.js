/**
 * Returns a new function generating iterators over values pushed by the `init` method.
 * Features:
 * - don't "swallow" provided data
 * - synchronizes data providers and consumers; useful to manage "backpressures"
 * - always notifies providers about the end of the iteration
 * @param init {Function} - a function accepting an object with the `next`,
 * `complete` and `error` methods and returning an optional cleanup method.
 *  Structure of the object accepted by the initialization function:
 *  - `async next(value)` - provides values for the iterator
 *  - `async complete()` - notifies about the end of iterations
 *  - `async error(error)` - notifies about an error generated by the provider
 *  This init method can return an optional cleanup function which is
 *  called at the end of the iteration process.
 * @param queue {object} an optional queue object providing two methods:
 *  - `async push(value)` - add a new value in the queue
 *  - `async shift()` - removes the first value from the queue
 * @return an async generator function returning provided values
 */
export function iterator(init, queue = []) {
  let promise, notify, push = async (error, value, done) => {
    const slot = { error, value, done };
    slot.promise = new Promise(n => slot.notify = n);
    await queue.push(slot);
    notify && notify();
    notify = null;
    return slot.promise;
  }
  const unsubscribe = init({
    next: value => push(undefined, value, false),
    error: err => push(err, undefined, true),
    complete: () => push(undefined, undefined, true)
  });
  
  return async function* () {
    let slot;
    try {
      while (true) {
        slot = await queue.shift();
        if (slot) {
          try {
            if (slot.error) { throw slot.error; }
            else if (slot.done) { break; }
            else { yield slot.value; }
          } finally {
            slot.notify(true);
          }
        } else {
          await (promise = notify ? promise : new Promise(n => notify = n));
        }
      }
    } finally {
      push = () => false; // Stop pushing in the queue...
      while (slot = await queue.shift()) { slot.notify(false); }
      ((typeof unsubscribe === 'function') && (await unsubscribe()));
    }
  }
}
