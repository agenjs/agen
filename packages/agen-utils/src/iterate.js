/**
 * Creates a new iterator and allows to "push" values to it.
 * Features:
 * - don't "swallow" provided data
 * - synchronizes data providers and consumers; useful to manage "backpressures"
 * - always notifies providers about the end of the iteration
 * @param init {Function} - a function accepting an object with the `next`,
 * `complete` and `error` methods and returning an optional cleanup method.
 *  Structure of the object accepted by the initialization function:
 *  - `async next(value)` - provides values for the iterator
 *  - `async complete()` - notifies about the end of iterations
 *  - `async error(error)` - notifies about an error generated by the provider
 *  This init method can return an optional cleanup function which is
 *  called at the end of the iteration process.
 * @return an async generator over provided values
 */
export function iterate(init, slots = []) {
  let finished, callback, promise = new Promise(c => callback = c);
  let push = async(error, value, done) => {
    if (finished) return ;
    const slot =  { error, value, done };
    slot.promise = new Promise(n => slot.notify = n);
    await slots.push(slot);
    finished = done;
    callback();
    return slot.promise;
  }
  const unsubscribe = init({
    next : value => push(undefined, value, false),
    error : err => push(err, undefined, true),
    complete : () => push(undefined, undefined, true)
  });
  let cleanup = async (error) => {
    finished = true;
    cleanup = push = () => {};
    let slot;
    while (slot = await slots.shift()) { slot.notify(); }
    if (typeof unsubscribe === 'function') await unsubscribe(error);
    return {};
  }
  return {
    [Symbol.asyncIterator] : function() { return this; },
    async next() {
      let slot;
      while (!slot) {
        await promise;
        slot = await slots.shift();
        if (slot) slot.notify();
        else promise = new Promise(c => callback = c);
      }
      if (slot.error) { await cleanup(slot.error); throw slot.error; }
      else if (slot.done) { await cleanup(); return { done : true }; }
      else return { value : slot.value };
    },
    return() { return cleanup(); },
    throw(e) { return cleanup(e); },
    error(e) { return cleanup(e); }
  }
}
